<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PacMan Proyect</title>
</head>
<style>
    canvas {
        background-color: #ebdbc0;
    }
    body {
        background-color: rgb(24, 26, 27);
    }
</style>
<body>

<canvas id="canvas" width="1000" height="700"></canvas>

<script>
    class Player {
        constructor(ctx, x, y, width, height, speed) {
            this.ctx = ctx;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.speed = speed;
            this.movement = "";
        }
        draw(direction) {

            switch (this.movement) {
                case "up":
                    ctx.drawImage(PlayerUp, this.x,this.y,this.width,this.height);
                    break;
                case "down":
                    ctx.drawImage(PlayerDown, this.x,this.y,this.width,this.height);
                    break;
                case "left":
                    ctx.drawImage(PlayerLeft, this.x,this.y,this.width,this.height);
                    break;
                case "right":
                    ctx.drawImage(PlayerRight, this.x,this.y,this.width,this.height);
                    break;
                default:
                ctx.drawImage(PlayerDefault, this.x,this.y,this.width,this.height);
                    break;
            }
        }

        move(direction) {
            this.movement = direction;
        }

        update(cw, ch, food, obstacles) {
            this.draw();

            switch (this.movement) {
                case "up":
                    this.y -= this.speed;
                    if (this.y < 0) {
                        this.y = ch;
                    }
                    break;
                case "down":
                    this.y += this.speed;
                    if (this.y > ch) {
                        this.y = -this.height;
                    }
                    break;
                case "left":
                    this.x -= this.speed;
                    if (this.x < 0) {
                        this.x = cw;
                    }
                    break;
                case "right":
                    this.x += this.speed;
                    if (this.x > cw) {
                        this.x = -this.width;
                    }
                    break;
            }

            if (this.x < food.x + food.width && this.x + this.width > food.x && this.y < food.y + food.height && this.y + this.height > food.y) {
                do {
                    score += 5;
                    food.updatePosition(cw, ch);
                } while (food.checkCollision(obstacles));
            }

            for (const obstacle of obstacles) {
                if (this.checkCollision(obstacle)) {
                    if (this.movement === "up" || this.movement === "down") {
                        this.y = this.movement === "up" ? obstacle.y + obstacle.height : obstacle.y - 50;
                    }
                    if (this.movement === "left" || this.movement === "right") {
                        this.x = this.movement === "left" ? obstacle.x + obstacle.width : obstacle.x - 50;
                    }
                    this.movement = "";
                }
            }
        }

        checkCollision(object) {
            return (
                this.x < object.x + object.width &&
                this.x + this.width > object.x &&
                this.y < object.y + object.height &&
                this.y + this.height > object.y
            );
        }
    }

    class Food {
        constructor(ctx, x, y, width, height) {
            this.ctx = ctx;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.eaten = false;
        }

        draw(color) {
            if (!this.eaten) {
                this.ctx.fillStyle = "yellow";
                this.ctx.fillRect(this.x, this.y, this.width, this.height);
                this.ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
           
        }
        

        checkCollision(object) {
            return (
                this.x < object.x + object.width &&
                this.x + this.width > object.x &&
                this.y < object.y + object.height &&
                this.y + this.height > object.y
            );
        }
    }

    class Obstacle {
        constructor(ctx, x, y, width, height, color) {
            this.ctx = ctx;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.color = color;
        }

        draw() {
            this.ctx.fillStyle = this.color;
            this.ctx.fillRect(this.x, this.y, this.width, this.height);
            this.ctx.strokeRect(this.x, this.y, this.width, this.height);
        }
    }
    
    class Enemy {
    constructor(ctx, width, height, speed, player, obstacles) {
        this.ctx = ctx;
        this.width = width;
        this.height = height;
        this.speed = speed;
        this.player = player;
        this.obstacles = obstacles;
        this.x = 0;
        this.y = 0;
        this.direction = this.randomDirection(); 
        this.spawnRandomPosition();
    }

    draw() {
        ctx.drawImage(EnemysIcon, this.x,this.y,this.width,this.height);
    }

    spawnRandomPosition() {
        let validPosition = false;
        
        while (!validPosition) {
            const randomX = randomInteger(cw - this.width);
            const randomY = randomInteger(ch - this.height);
            
        
            const collidesWithObstacle = this.obstacles.some(obstacle => {
                return (
                    randomX < obstacle.x + obstacle.width &&
                    randomX + this.width > obstacle.x &&
                    randomY < obstacle.y + obstacle.height &&
                    randomY + this.height > obstacle.y
                );
            });
            
            if (!collidesWithObstacle) {
                this.x = randomX;
                this.y = randomY;
                validPosition = true;
            }
        }
    }

    isTooCloseToPlayer() {
        const distance = Math.sqrt(
            Math.pow(this.x - this.player.x, 2) + Math.pow(this.y - this.player.y, 2)
        );
        return distance < 100;
    }

    randomDirection() {
        const directions = ["up", "down", "left", "right"];
        return directions[Math.floor(Math.random() * directions.length)];
    }

    move() {
        
        switch (this.direction) {
            case "up":
                this.y -= this.speed;
                break;
            case "down":
                this.y += this.speed;
                break;
            case "left":
                this.x -= this.speed;
                break;
            case "right":
                this.x += this.speed;
                break;
        }
        if (this.checkCollision(this.obstacles)) {
            this.x -= this.speed;
            this.randomDirection();
        }
       
        this.avoidObstacles();
    }

    avoidObstacles() {
       
        let nextX = this.x;
        let nextY = this.y;

        switch (this.direction) {
            case "up":
                nextY -= this.speed;
                break;
            case "down":
                nextY += this.speed;
                break;
            case "left":
                nextX -= this.speed;
                break;
            case "right":
                nextX += this.speed;
                break;
        }

        let canMove = true;

       
        for (const obstacle of this.obstacles) {
            if (
                nextX < obstacle.x + obstacle.width &&
                nextX + this.width > obstacle.x &&
                nextY < obstacle.y + obstacle.height &&
                nextY + this.height > obstacle.y
            ) {
                canMove = false;
                break;
            }
        }

        if (!canMove) {
            
            this.direction = this.randomDirection();
        }
    }

    checkCollision(object) {
        return (
            this.x < object.x + object.width &&
            this.x + this.width > object.x &&
            this.y < object.y + object.height &&
            this.y + this.height > object.y
        );
    }
    checkCollisionWithOtherEnemies(enemies) {
        for (const enemy of enemies) {
            if (enemy !== this && this.checkCollision(enemy)) {
                this.direction = this.randomDirection();
                break;
            }
        }
    }
}


    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const cw = 1000, ch = 700;
    let score = 0; //Max 3930
    let paused = false;
    let pausedSpeed = 0;
    let foodEating =0; //Max 785
    let gameIsOver = false;
    
    const player = new Player(ctx, 275, 275,50,50, 5);
    let PlayerUp= new Image();
    PlayerUp.src = "./src/Mouse-up.PNG";
    let PlayerDown= new Image();
    PlayerDown.src = "./src/Mouse-down.PNG";
    let PlayerLeft= new Image();
    PlayerLeft.src = "./src/Mouse-left.PNG";
    let PlayerRight= new Image();
    PlayerRight.src = "./src/Mouse-right.PNG";
    let PlayerDefault= new Image();
    PlayerDefault.src = "./src/Mouse-default.PNG";
    

    const foods = [];
    const foodSpacing = 5
    const foodWidth = 15;
    const foodHeight = 15;

    let EnemysIcon = new Image();
    EnemysIcon.src = "src/Kitty-enemy.png";


    const obstacles = [

        new Obstacle(ctx, 0, 0, 30, 300, "#ebdbc0"),
        new Obstacle(ctx, cw-25, 0, 30, 300, "#ebdbc0"),
        new Obstacle(ctx, 0, 400, 30, 300, "#ebdbc0"),
        new Obstacle(ctx, cw-25, 400, 30, 300, "#ebdbc0"),


        new Obstacle(ctx, 30, 15, 945, 20, "#8b501f"),
        new Obstacle(ctx, 30, ch-25, 945, 20, "#8b501f"),

        new Obstacle(ctx, 20, 15, 20, 290, "#8b501f"),
        new Obstacle(ctx, cw-45, 5, 20, 300, "#8b501f"),
        
        new Obstacle(ctx, 20, 400, 20, 295, "#8b501f"),
        new Obstacle(ctx, cw-45, 400, 20, 295, "#8b501f"),

        new Obstacle(ctx, -10, 285, 50, 20, "#8b501f"),
        new Obstacle(ctx, cw-45, 285, 50, 20, "#8b501f"),

        new Obstacle(ctx, -10, 400, 50, 20, "#8b501f"),
        new Obstacle(ctx, cw-45, 400, 50, 20, "#8b501f"),


        new Obstacle(ctx, 125, 115, 330, 20, "#8b501f"),
        new Obstacle(ctx, cw-450, 115, 330, 20, "#8b501f"),

        new Obstacle(ctx, 125, 580, 330, 20, "#8b501f"),
        new Obstacle(ctx, cw-450, 580, 330, 20, "#8b501f"),
        

        new Obstacle(ctx, 125, 205, 20, 295, "#8b501f"),
        new Obstacle(ctx, cw-140, 205, 20, 295, "#8b501f"),

        new Obstacle(ctx, 230, 215, 545, 20, "#8b501f"),
        new Obstacle(ctx, 230, ch-220, 545, 20, "#8b501f"),

        new Obstacle(ctx, 125, 332, 200, 40, "#8b501f"),
        new Obstacle(ctx, cw-320, 332, 200, 40, "#8b501f"),

        new Obstacle(ctx, 405, 305, 20, 100, "#8b501f"),
        new Obstacle(ctx, cw-415, 305, 20, 100, "#8b501f"),

        new Obstacle(ctx, 405, 385, 200, 20, "#8b501f"),
        
    ];

    const enemies = [];
    const numEnemies = 5;

    for (let i = 0; i < numEnemies; i++) {
        const enemy = new Enemy(ctx, 50, 50, 3, player, obstacles);
        enemies.push(enemy);
    }

    for (let x = foodWidth; x < cw; x += (foodWidth * 2 + foodSpacing)) {
        for (let y = foodHeight; y < ch; y += (foodHeight * 2 + foodSpacing)) {
            let foodOverlapsObstacle = false;
            let foodOverlapsPlayer = false;
            
            
            for (const obstacle of obstacles) {
                if (
                    x < obstacle.x + obstacle.width &&
                    x + foodWidth > obstacle.x &&
                    y < obstacle.y + obstacle.height &&
                    y + foodHeight > obstacle.y
                ) {
                    foodOverlapsObstacle = true;
                    break; 
                }
            }
            
            if (
                x < player.x + player.width &&
                x + foodWidth > player.x &&
                y < player.y + player.height &&
                y + foodHeight > player.y
            ) {
                foodOverlapsPlayer = true;
            }
            
            if (!foodOverlapsObstacle && !foodOverlapsPlayer) {
                foods.push(new Food(ctx, x, y, foodWidth, foodHeight));
            }
        }
    }

    window.requestAnimationFrame = (function () {
        return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 30);
            };
    }());

    document.addEventListener("keydown", (event) => {
        switch (event.keyCode) {
            case 87:
                player.move("up");
                break;
            case 83:
                player.move("down");
                break;
            case 65:
                player.move("left");
                break;
            case 68:
                player.move("right");
                break;
            case 80:
            PauseAll();
                break;

        }
    });

    function PauseAll() {
        paused = !paused;
        if (paused) {
            pausedSpeed = player.speed;
            player.speed = 0;
            for (const enemy of enemies) {
                enemy.pausedSpeed = enemy.speed;
                enemy.speed = 0;
            }
        
        } else {
            
            player.speed = pausedSpeed;
            for (const enemy of enemies) {
                enemy.speed = enemy.pausedSpeed;
            }
        }
    }
    function draw() {
        
        ctx.clearRect(0, 0, cw, ch);

       for (const food of foods) {
        food.draw();

            if (!food.eaten && player.checkCollision(food)) {
                food.eaten = true;
                foodEating += 1;
                score += 5;
            }
        }
    
        for (const enemy of enemies) {
            enemy.draw();
        }
    
        for (const obstacle of obstacles) {
            obstacle.draw();
        }
        
        if (gameIsOver === true) {
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, cw, ch);
            ctx.font = "35px Impact";
            ctx.fillStyle = "white";
            ctx.fillText("GAME OVER!", 425, 300);
            ctx.fillText("Press (R) to Reload", 370, 360);

            document.addEventListener("keydown", (event) => {
                if (event.keyCode === 82) { 
                    location.reload();
                }
            });
        }

        if (paused) {
            ctx.fillStyle = "rgba(184, 184, 184,0.5)";
            ctx.fillRect(0, 0, 1000, 700);
            ctx.font = "35px Impact";
            ctx.fillStyle = "black";
            ctx.fillText("Â¡Paused!", 425, 300);
            ctx.fillText("Press (P) to continue", 350, 360);
        }
        
        ctx.lineWidth = 2;
        ctx.font = "35px Impact";
        ctx.fillStyle = "#ffffff"; 
        ctx.fillText("Score: " + score, 440, 40); 
        ctx.fillText("P: Paused", 80, 690); 
        ctx.fillText("Space: +speed", 720, 690); 
        ctx.fillStyle = "#000000";
        ctx.strokeText("Score: " + score, 440, 40); 
        ctx.strokeText("P: Paused", 80, 690); 
        ctx.strokeText("Space: +speed", 720, 690); 

    }

    function updateEnemies() {
        for (const enemy of enemies) {
            enemy.checkCollisionWithOtherEnemies(enemies);
            enemy.move();
        }
    }

    function update() {
        if (!paused) {
            ctx.clearRect(0, 0, cw, ch);
            let collisionDetected = false;

            if (
                !collisionDetected &&
                player.x < foods.x + 30 &&
                player.x + 50 > food.x &&
                player.y < food.y + 30 &&
                player.y + 50 > food.y
            ) {
                score += 5;
                food.updatePosition(cw, ch);
                collisionDetected = true;
            }
            for (const enemy of enemies) {
                if (player.checkCollision(enemy)) {
                    gameIsOver = true;
                }
            }
            updateEnemies();
        }

    player.update(cw, ch, foods, obstacles);
    draw();
    requestAnimationFrame(update); // Move this line outside of the condition
}


    update();

    function randomInteger(max) {
        return Math.floor(Math.random() * (max + 1));
    }

</script>

</body>
</html>
